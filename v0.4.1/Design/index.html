<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Design of the Package · Autologistic.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Autologistic.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../Background/">Background</a></li><li class="current"><a class="toctext" href>Design of the Package</a><ul class="internal"><li><a class="toctext" href="#Type-Hierarchy-1">Type Hierarchy</a></li><li><a class="toctext" href="#Important-Notes-1">Important Notes</a></li><li><a class="toctext" href="#Random-Sampling-1">Random Sampling</a></li></ul></li><li><a class="toctext" href="../BasicUsage/">Basic Usage</a></li><li><a class="toctext" href="../Examples/">Examples</a></li><li><a class="toctext" href="../api/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Design of the Package</a></li></ul><a class="edit-page" href="https://github.com/kramsretlow/Autologistic.jl/blob/master/docs/src/Design.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Design of the Package</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Design-of-the-Package-1" href="#Design-of-the-Package-1">Design of the Package</a></h1><p>The package was created to satisfy the following goals:</p><ul><li>To make it easy for researchers to compare the different variants of the AL/ALR models (different combinations of coding and centering), to test the claim that the symmetric model is superior to the other alternatives.</li><li>To facilitate analysis of real-world data sets with correlated binary responses, hopefully with good performance.</li><li>To create a code base that is fairly easy to extend as new extensions on AL/ALR models are developed.</li></ul><p>These goals guided the design of the package, which is briefly described here.</p><h2><a class="nav-anchor" id="Type-Hierarchy-1" href="#Type-Hierarchy-1">Type Hierarchy</a></h2><p>Three abstract types are used to define a type hierarchy that will hopefully allow the codebase to be easily extensible.  The type <code>AbstractAutologisticModel</code> is the top-level type for AL/ALR models.  Most of the functions for computing with AL/ALR models are defined to operate on this type, so that concrete subtypes should not have to re-implement them.</p><p>The <code>AbstractAutologisticModel</code> interface requires subtypes to have a number of fields.  Two of them are <code>unary</code> and <code>pairwise</code>, which must inherit from <code>AbstractUnaryParameter</code> and <code>AbstractPairwiseParameter</code>, respectively.  These two abstract types define interfaces for the unary and pairwise parts of the model. Concrete subtypes of these two types represent different ways of parametrizing the unary and pairwise terms.</p><p>For example, the most useful ALR model implemented in the package is the model with a linear predictor as the unary parameter (<span>$\boldsymbol{\alpha}=\mathbf{X}\boldsymbol{\beta}$</span>), and the &quot;simple pairwise&quot; assumption for the pairwise term (<span>$\boldsymbol{\Lambda} = \lambda\mathbf{A}$</span>).  This model has type <code>ALRsimple</code>, with unary type <code>LinPredUnary</code> and pairwise type <code>SimplePairwise</code>.  A model of this type can be instantiated with any desired coding, and different forms of centering.</p><p>With this design, adding a new type of AL/ALR model with a different parametrization involves</p><ul><li>Creating <code>NewUnaryType &lt;: AbstractUnaryParameter</code></li><li>Creating <code>NewPairwiseType &lt;: AbstractPairwiseParameter</code></li><li>Creating <code>NewModelType &lt;: AbstractAutologisticModel</code>, including instances of the two new types as its <code>unary</code> and <code>pairwise</code> fields.</li></ul><p>This process should not be too cumbersome, as the unary and pairwise interfaces mainly require implementing indexing and show methods. Sampling, computation of probabilities, handling of centering, etc., is handled by fallback methods in the abstract types.</p><h2><a class="nav-anchor" id="Important-Notes-1" href="#Important-Notes-1">Important Notes</a></h2><p>Here are a few points to be aware of in using the package.  For this list, let <code>M</code> be a an AL or ALR model type.</p><ul><li>Responses are stored in <code>M.responses</code> as arrays of type <code>Bool</code>.</li><li>The coding is stored separately in <code>M.coding</code>.  Not storing the responses as a numeric type makes it easier to maintain consistency when working with models that might have different codings.</li><li>Use functions <code>makebool</code> and <code>makecoded</code> to get to and from coded/boolean forms of the responses.</li><li>Parameters are always represented as <strong>vectors</strong> of <code>Float64</code>, with unary parameters first and pairwise parameters at the end.  </li><li>The above is true even when the parameter only has length 1, as with the <code>SimplePairwise</code> type.  So you need to use square brackets, as in <code>setparameters!(MyPairwise, [1.0])</code>, when setting the parameters in that case.</li><li>The package uses <a href="https://github.com/JuliaGraphs/LightGraphs.jl">LightGraphs.jl</a> for representing graphs, and <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> for optimization.</li></ul><h2><a class="nav-anchor" id="Random-Sampling-1" href="#Random-Sampling-1">Random Sampling</a></h2><p>Random sampling is particularly important for AL/ALR models, because (except for very small models), it isn&#39;t possible to evaluate the normalized PMF.  Monte Carlow approaches to Estimation and inference are common with these models.  </p><p>The <code>sample</code> function is provided for random sampling from an AL/ALR model.  The function takes a <code>method</code> argument, which specifies the sampling algorithm to use. Use <code>?SamplingMethods</code> at the REPL to see the available options.  </p><p>The default sampling method is Gibbs sampling, since that method will always work.  But there are several perfect (exact) sampling options provided in the package.  Depending on the model&#39;s parameters, perfect sampling will either work just fine, or be prohibitively slow.  It is recommended to use one of the perfect sampling methods if possible. The different sampling algorithms can be compared for efficiency in particular cases.</p><footer><hr/><a class="previous" href="../Background/"><span class="direction">Previous</span><span class="title">Background</span></a><a class="next" href="../BasicUsage/"><span class="direction">Next</span><span class="title">Basic Usage</span></a></footer></article></body></html>
